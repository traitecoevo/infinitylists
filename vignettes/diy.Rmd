---
title: "Create your own infinitylists"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{DIY infinitylists}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

One major benefit of infinitylists utilising a Living Atlas node is that is gives users the potential to create their own version of infinitylists for whichever Living Atlas you would like to use. Unfortunately, there are some slight inconsistencies in data coverage and naming between Living Atlas data providers. This makes creating your own infinitylists not an entirely straightforward process but I hope this article will be able to give you some guidance.

Here, I will walk through the process on how to adapt the source code of infinitylists so you can create your own version of infinitylists. 

I recommend using git and Github to streamline the refactoring process but it is not a necessity. In this article, we will operate as if we are not using git/Github, but I will leave some prompts for git users. If you want to learn how to use git/Github alongside your R coding projects, I highly recommend Happy with Git by Jenny Bryan if you want to add these tools to your arsenal. 

If you have any questions about this process, please do not hesitate and reach out but submitting an issue at the [infinitylists repository](XX).

## Load dependencies

We are going to need a few packages to create your own infinitylists. Go ahead and install these if you don't have these in your version of R. Otherwise, load them and we can get started 

```{r setup}
# install.packages("devtools")
devtools::install_github("traitecoevo/infinitylists")
library(devtools)
library(infinitylists)
library(galah)
library(tidyverse)
```

## Download source code of infinitylist

First things first, we need to get our hands on a version of the infinitylists source code. The app's source code lives at the [GitHub repository](). Head over to the repository's website and find the big green botton labelled **"Code"**.

1) Click on the **"Code"** button
2) Click on the option to download code as a `.zip` file
3) Locate the `.zip` file in your Downloads folder and move it to where you want the code to live in your computer. 
4) Once you are happy with the location, double click on the `.zip` file to unzip it. 

Hooray! We have a copy of the source code now!

If you are a git/Github user, I would suggest you to fork the infinitylist repository and clone it locally to where you want. 

### The key files

infinitylists is a Shiny R package. Totally okay if you not written a shiny app or R package, I will point one which are the important files for you edit and explain what they do as we go along. The most important folder we will be using is the 'R/' folder. It holds all the code to download biodiversity data and create the the application. 

Within this folder, you will find: 
- `ui.R`, this file controls the overall look of the application. ui stands for user interface. 
- `server.R`, this file controls how the app behaves. e.g. Clicking "Go" will trigger a specific spatial filter process and update the map and observations table. 
- `global.R`, contains some functions that are used across the application. 

These are the three major files we will refactor so you can create your own version of infinitylists

## Download Living Atlas data

The next thing we need to decide which Living Atlas we want to use. Here, we will use [Spain's Living Atlas](). Note that some living atlas will require you to sign up for an account so you can download occurrence records. I signed up for an account for the Spain Living atlas [here](). 

### Configure galah

We will be using {galah} to download occurrence records used our infinitylist. To do so, we need to configure the settings so it knows which Living Atlas to target. Here I've saved the credentials in my R environment so its not shared publicly. I can call on these environment variables using `Sys.getenv()`. You can also do so with `usethis::edit_r_environ`. See [here]() to learn more about editting your R environment. 

```{r}
galah::galah_config(email = Sys.getenv("GBIF_EMAIL"),
                    password = Sys.getenv("GBIF_PWD"),
                    atlas = "Spain")
```

### Check if specific fields are available

infinitylists downloads a specific subset of data from the Living Atlas. We need to check if these fields of data are available in the atlas you have selected. [See here]() to see the differences between the available atlases. 

The fields we need are found in `R/galah_download.R`, specifically under the `query()` function. 

I've included a list of data field names here too so you don't need to flip back and forth between files: 

- spatiallyValid
- species
- decimalLatitude
- year
- basisOfRecord == c("HUMAN_OBSERVATION", "PRESERVED_SPECIMEN")
- recordID
- species
- genus
- family
- decimalLatitude
- decimalLongitude
- coordinateUncertaintyInMeters
- eventDate
- datasetName
- basisOfRecord
- references
- institutionCode
- recordedBy
- sounds

Remember how I said there are inconsistencies between Living Atlases? For example, The Austria atlass uses snake_case (lower case words, seperated by an underscore), whereas Australia uses camelCase (second word in the string is capitalised). Another common difference example is where some atlases uses `spatiallyValid` while others uses `geospatial_kosher`. 

To deal with these consistencies, I use a combination of `search_()` and `show_()` functions from {galah} to determine whether the field we need for infinitylists is available and how the data is formatted. If it's not, we may need remove some of the functionality of the app.

Here, I am looking for field names that contains the partial string "spatial"

```{r}
# Look for a certain string in field names
search_fields("spatial")
```

You can search across other  entities by using `search_all()` instead. Check out the helpfile for details on what is captured in the search `?search_all()`


### Check fields are formatted 

You can pipe the contents of the search into `show_values()` to see the values the data field holds

For example, here I am searching for fields that contain the partial string `coord` and I want to see what values each matching field looks like. This will help me narrow down finding the corresponding field I need. 

```{r}
# Search across fields for "coord" 
search_all(fields, "coord") |>
  show_values() # Display the field values
```

Another option is to  look across all the fields the Living Atlas has data for and see if you can spot the ones that resemble the ones in the list above.

```{r} 
# Display all the fields available
show_all_fields() |>
  print(n = Inf) # Print all of these in the console
```

#### Edit the download functions

So you found some differences with field names for our chosen Living Atlas and the Australian infinitylists code? Thats totally okay. 

We will now edit the files that uses these field names directly. 

The two functions you will need to refactor are in `galah_download.R`: 

- `query()` 
- `process_data()` 

Systemically, edit each function

### A test run

Before we launch in and download all the records for large taxonomic group, let's do a test run first. Just to make sure it works. 

We will make use of the internal function `query()` function from infinitylists. We need to use the `:::` to access this function. 

The `query()` function is where we specify what taxonomic group we want to download data for. As an example, I have selected a genus of lizards found across Europe "Podarcis". You also need to decide what year interval you want data for. I'm going for 2023 - 2024 here. 

Here you can see the `query()` function produce the search query we need for the app

```{r}
# Create a download query
infinitylists:::query("Podarics", c(2023, 2024)) 
```

Next, I will pipe the results of the query into `atlas_counts` to see how many observations we will be downloading.

```{r}
infinitylists:::query("Podarics", c(2023, 2024)) 
```

Now we are ready download our test dataset

```{r}
podarcis_test <- infinitylists:::query("Podarics", c(2023, 2024)) |> 
  atlas_occurrences()
```

### Check data processing

infinitylists doesn't work with the raw data downloaded from the Living Atlas. There is code to process it down, filtering it, creating some new useful variables before saving it for use later. 

#### Inclusions and exclusions

This step is handled by the function `process_data()`. This function keeps the data for records where: 

- The `basisOfRecord` is a preserved specimen **OR**
- The`datasetName` contains: 
  - "Australia's Virtual Herbarium"
  - "iNaturalist observations"
  - "iNaturalist research-grade observations"
  
The function also filters for records where: 
- the `coordinateUncertaintyInMeters` is either  NA **OR** have a value of less than or equal to 1000. 

This is because some iNaturalist records have NA for `coordinateUncertaintyInMeters`. 

The function also excludes records where: 
- eventDate is missing
- the subspecies is in the `species` field. e.g. "Acacia longifolia spec." would be excluded. 

#### Create a few useful variables




### Determine establishment means

One key feature in the Australian infinitylist is the data field 'Establishment means' which denotes whether a species is native, introduced or unkown. This information is also summarised in the bolded statement at the lower portion of the app. For Plantae, establishment means is determined by the R package [APCalign](), for the other taxa (XX, XX, XX), these were manually coded by hand using a series of `if` statements.

We suspect this feature of the Australian infinitylis is not completely transferable using other Living Atlases as knowledge of establishment means of taxa is required beforehand. 

We suggest relying on the Global Register of Introduced and Invasive Species (GRIIS) list and we present the workflow below

```{r establishment}

```



### Check base URL for each record 

Another important feature of infinitylists is the ability for each record to be linked to the original GBIF/iNaturalist page. This allows the user to dig deeper about the record or review photos taken by citizen scientists.

For the Australian's infinitylist, the URL for specimen records takes the user to the Atlas of Living Australia. This URL will need to change according to the Living Atlas you choose. 

This is where you will need to do some investigating. Finding these record specific pages is a bit tricky. I clicked around the GBIF Spain website to find... 

In some cases the recordID provided by galah may not match the unique identifier used by pages, sometimes this identifier is located under `GBIF_id`. This means you may need to add `GBIF_id` into the `query()` function so you can access this data later. 

<!-- Investigate recordId and GBIF_id -->
 <!-- https://registros.gbif.es/occurrences/1dfb057c-6e0d-494f-a3f2-812770d49bfd -->

Once I found the correct base URL, I took note of it, and started testing it out with different unique identifiers to see if I can get the correct page to match the occurrence record. 

```{r}

```

Now that I'm happy with the base URL and how it works with the identifiers, I'm ready to update the code. 

You will need to update in this line of code in `process_data()` function in `R/galah_download`. Replace `https://biocache.ala.org.au/occurrences/` with your base URL. 

```
TRUE ~ paste0("https://biocache.ala.org.au/occurrences/", recordID))
```

## Relevant regions of interest

infinitylists comes preloaded with XX regions of interest. These were created from `.kml` files. If you want your version of infinitylist to come up preloaded regions of interest, you will need to find/create `.kml` files of your own. 

You can download these from: 

Alternatively, you can hand draw these using Google Earth and export these. Follow this website for more details

## Default location input